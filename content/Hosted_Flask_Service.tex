\chapter{hosted Flask Service}
\label{cha:hosted_flask_service}


This chapter delineates the implementation, architecture, and deployment of the self-hosted Flask service, 
which functions as a pivotal interface between the front-end and back-end components of the system. 
In addition to detailing the technical design, the chapter critically examines the advantages of a self-hosted solution 
and the rationale behind key architectural decisions.


% Hier beschreiben wir wie wir unseren Flask Service gehostet bzw. Geschreiben haben und im Server implementiert haben

% ##########################################
\section{Introduction}
This section provides a comprehensive overview of the motivations for developing the Flask service. It discusses the specific requirements that necessitated the service, outlines its core functionalities, and situates the service within the broader system architecture.

\section{Advantages of a Self-hosted Service}
In this section, the benefits of deploying a self-hosted service are explored in depth. The discussion includes:
\begin{itemize}
    \item Enhanced customization and control over the service environment.
    \item The ability to rapidly prototype and deploy bespoke functionalities.
    \item Improved data security and compliance with institutional policies.
\end{itemize}
These factors collectively underscore the strategic choice of a self-hosted approach over third-party solutions.

\section{Architecture and Service Structure}
\subsection{System Architecture}
This subsection describes the monolithic architecture of the Python Flask server, elucidating how various components are integrated to form a cohesive whole. The internal workflow and interaction between modules are detailed to provide a clear picture of the service's operational logic.
\subsection{Modularity and Extensibility}
An emphasis is placed on the modular design of the service, which facilitates maintainability and scalability. This part discusses the design choices that allow for future enhancements and the integration of additional functionalities.

\section{Flask as a Web Framework}
\subsection{Core Functionalities}
This subsection explains the intrinsic capabilities of Flask, such as request routing, templating, and middleware support. It illustrates how these features are employed to manage web requests and responses within the service.
\subsection{Rationale for Selecting Flask}
A critical discussion is presented on why Flask was chosen for the project. Key factors include its simplicity, extensive documentation, and robust community support, which collectively make it an ideal framework for rapid development and prototyping.

\section{RESTful Endpoints and Functionalities}
\subsection{Endpoint Specifications}
This section enumerates the various RESTful endpoints implemented in the service. Each endpoint is described in detail, outlining its specific purpose and the type of data it handles.
\subsection{Code Illustrations}
To enhance understanding, code examples are provided to demonstrate the implementation of key endpoints. These examples highlight the methods used to process requests and generate responses.
\subsection{Utility Functions}
An overview of auxiliary utility functions is given, focusing on their roles in logging, data validation, and error handling. These functions contribute to the overall robustness and reliability of the service.

\section{Utilized Libraries}
A comprehensive inventory of the external libraries used in the project is presented in this section. For each library, its functionality, role within the project, and integration aspects are discussed.

%###################

\section{Docker}
Docker is a platform that allows you to run applications in containers. A container is like a small, isolated environment where software runs with everything it needs – including the operating system, libraries, and dependencies.

No matter which computer or server the container runs on, it always works the same way. This means you don’t have to worry about an application suddenly throwing errors on a different system just because a different software version is installed there.

Docker is often used in software development and cloud applications because it simplifies testing, deployment, and scaling of apps. Developers can store their software as images and share them with others without requiring complicated installations.

\subsection{Used Docker Images}
A docker image is a bluebrint that specifies how to run the application. The Instructions for the build are stored in the Dockerfile.
\cite{dockerize_flask} 

\begin{itemize}
    \item \textbf{flask_app} The flask image is used to easily implement the flask application in a docker container
    \item \textbf{ollama} The ollama image is used to avoid running llms globally and use them in a secluded environment.
\end{itemize}

\subsection{Docker Compose}
Docker Compose is used for running multiple containers at the same time. It simplifies your application and makes it easier to manage 
The Configuration is stored in a single YAML file. All the services can be started with a simpel command. It is a very compact way to manage Docker application.
\cite{docker_compose} 

\section{Deployment}

% How we deployed the Server on a Laptop, The School Server and on our Server via Docker
% Explain how we Deployed the Server on a Laptop, The School Server and on our Server via Docker (Docker gets Explained in the next Section)

\section{Conclusion and Future Work}
This concluding section synthesizes the chapter’s key points and reflects on the efficacy of the implemented service. It also outlines potential avenues for future enhancements, such as further scalability improvements, additional functionalities, and more robust deployment automation.





