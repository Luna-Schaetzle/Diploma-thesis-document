\chapter{hosted Flask Service}
\label{cha:hosted_flask_service}
\textbf{Author:} Luna P. I. Schätzle

\textbf{Author:} Florian Prandstetter (docker section \ref{sec:docker})

This chapter delineates the implementation, architecture, and deployment of the self-hosted Flask service, 
which functions as a pivotal interface between the front-end and back-end components of the system. 
In addition to detailing the technical design, the chapter critically examines the advantages of a self-hosted solution 
and the rationale behind key architectural decisions.

\section{Introduction}
This section offers a comprehensive overview of the motivations underpinning the development of the Flask service. 
Functioning as the backbone for both the Student AI Hub and the code extension’s backend, 
the service was conceived to address a range of specific operational requirements. 
Here, we elaborate on the core functionalities of the service, detail the technical imperatives that drove its inception, 
and position its role within the broader system architecture, thereby laying the groundwork for subsequent technical discussions.

\section{Advantages of a Self-hosted Service}
A self-hosted service confers a multitude of benefits relative to externally managed or third-party solutions. This section examines these advantages in depth:
\begin{itemize}
    \item \textbf{Enhanced Customization and Environmental Control:} By hosting the service internally, developers gain complete authority over the configuration and optimization of the operating environment. This control facilitates the implementation of domain-specific modifications and enables precise tuning to meet the unique needs of the project.
    \item \textbf{Rapid Prototyping and Agile Deployment:} The self-hosted nature of the service supports agile development practices. New features and bespoke functionalities can be rapidly prototyped, iteratively tested, and deployed, thereby significantly reducing development cycles and accelerating time-to-market.
    \item \textbf{Improved Data Security and Regulatory Compliance:} Hosting the service in-house allows for stringent oversight of data management practices. This approach is particularly advantageous in contexts governed by strict data protection regulations and institutional policies, as it enables the implementation of tailored security measures and enhances overall control over sensitive information.
\end{itemize}
Collectively, these factors validate the strategic decision to pursue a self-hosted approach, underscoring its technical, operational, and regulatory merits.

% ***************************************************

\section{Architecture and Service Structure}

To provide a comprehensive understanding of the Flask service, this section delves into its architectural design and internal structure.

\subsection{System Architecture}

This subsection describes the architecture of the Python Flask server, elucidating how various components are integrated to form a cohesive whole. The internal workflow and interaction between modules are detailed to provide a clear picture of the service's operational logic.

\subsection{Modularity and Extensibility}

An emphasis is placed on the modular design of the service, which facilitates maintainability and scalability. This part discusses the design choices that allow for future enhancements and the integration of additional functionalities.

\section{Flask as a Web Framework}

\subsection{Core Functionalities of Flask}
This subsection explains the intrinsic capabilities of Flask, such as request routing, templating, and middleware support. It illustrates how these features are employed to manage web requests and responses within the service.

\subsection{Rationale for Selecting Flask}
A critical discussion is presented on why Flask was chosen for the project. Key factors include its simplicity, extensive documentation, and robust community support, which collectively make it an ideal framework for rapid development and prototyping.

\section{RESTful Endpoints and Functionalities}
\label{sec:endpoints}
\subsection{Endpoint Specifications}
This section enumerates the various RESTful endpoints implemented in the service. Each endpoint is described in detail, outlining its specific purpose and the type of data it handles.

\subsection{Code Illustrations}
To enhance understanding, code examples are provided to demonstrate the implementation of key endpoints. These examples highlight the methods used to process requests and generate responses.
\subsection{Utility Functions}
An overview of auxiliary utility functions is given, focusing on their roles in logging, data validation, and error handling. These functions contribute to the overall robustness and reliability of the service.


\section{Utilized Libraries}
A comprehensive inventory of the external libraries used in the project is presented in this section. For each library, its functionality, role within the project, and integration aspects are discussed.

%###################

\section{Deployment}

% How we deployed the Server on a Laptop, The School Server and on our Server via Docker
% Explain how we Deployed the Server on a Laptop, The School Server and on our Server via Docker (Docker gets Explained in the next Section)

\section{Docker}
\label{sec:docker}
Docker is a platform that allows you to run applications in containers. A container is like a small, isolated environment where software runs with everything it needs – including the operating system, libraries, and dependencies.

No matter which computer or server the container runs on, it always works the same way. This means you don’t have to worry about an application suddenly throwing errors on a different system just because a different software version is installed there.

Docker is often used in software development and cloud applications because it simplifies testing, deployment, and scaling of apps. Developers can store their software as images and share them with others without requiring complicated installations.

\subsection{Used Docker Images}
A docker image is a blueprint that specifies how to run the application. The instructions for the build are stored in the Dockerfile.
\cite{dockerize_flask} 

\begin{itemize}
    \item \textbf{flask\_app} The Flask image is used to easily implement the Flask application in a Docker container.
    \item \textbf{ollama} The Ollama image is used to avoid running LLMs globally and use them in a secluded environment.
\end{itemize}

\subsection{Docker Compose}
Docker Compose is used for running multiple containers at the same time. It simplifies your application and makes it easier to manage 
The Configuration is stored in a single YAML file. All the services can be started with a simpel command. It is a very compact way to manage Docker application.
\cite{docker_compose} 

\author{Florian Prandstetter}

\section{Scalability and Performance Concerns}

One notable limitation of the Flask server is its inherent lack of scalability. Flask, being primarily designed for lightweight applications, is not optimized for handling high volumes of concurrent requests. In our implementation, the server was deployed on a modest PC with limited computational resources. Consequently, if the service were to be deployed in a production environment, it would be imperative to migrate to more robust hardware or consider a distributed, multi-server architecture to effectively manage the anticipated load. Given the constraints of the project timeline and the prototype nature of this work, scalability was not prioritized during development.

% ########################################

\section{Conclusion and Future Work}
This concluding section synthesizes the chapter’s key points and reflects on the efficacy of the implemented service. It also outlines potential avenues for future enhancements, such as further scalability improvements, additional functionalities, and more robust deployment automation.





