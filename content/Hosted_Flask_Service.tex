\chapter{hosted Flask Service}
\label{cha:hosted_flask_service}
\textbf{Author:} Luna P. I. Schätzle

\textbf{Author:} Florian Prandstetter (docker section \ref{sec:docker})

This chapter delineates the implementation, architecture, and deployment of the self-hosted Flask service, 
which functions as a pivotal interface between the front-end and back-end components of the system. 
In addition to detailing the technical design, the chapter critically examines the advantages of a self-hosted solution 
and the rationale behind key architectural decisions.

\section{Introduction}
This section offers a comprehensive overview of the motivations underpinning the development of the Flask service. 
Functioning as the backbone for both the Student AI Hub and the code extension’s backend, 
the service was conceived to address a range of specific operational requirements. 
Here, we elaborate on the core functionalities of the service, detail the technical imperatives that drove its inception, 
and position its role within the broader system architecture, thereby laying the groundwork for subsequent technical discussions.

\section{Advantages of a Self-hosted Service}
A self-hosted service confers a multitude of benefits relative to externally managed or third-party solutions. This section examines these advantages in depth:
\begin{itemize}
    \item \textbf{Enhanced Customization and Environmental Control:} By hosting the service internally, developers gain complete authority over the configuration and optimization of the operating environment. This control facilitates the implementation of domain-specific modifications and enables precise tuning to meet the unique needs of the project.
    \item \textbf{Rapid Prototyping and Agile Deployment:} The self-hosted nature of the service supports agile development practices. New features and bespoke functionalities can be rapidly prototyped, iteratively tested, and deployed, thereby significantly reducing development cycles and accelerating time-to-market.
    \item \textbf{Improved Data Security and Regulatory Compliance:} Hosting the service in-house allows for stringent oversight of data management practices. This approach is particularly advantageous in contexts governed by strict data protection regulations and institutional policies, as it enables the implementation of tailored security measures and enhances overall control over sensitive information.
\end{itemize}
Collectively, these factors validate the strategic decision to pursue a self-hosted approach, underscoring its technical, operational, and regulatory merits.


\section{Architecture and Service Structure}

The Flask service functions as a robust and flexible backend for the Student AI Hub and the code extension. Its modular and extensible design facilitates the seamless integration of additional functionalities and services. The figure below illustrates the key architectural components of the Flask service and their interactions.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{figures/flask_service.png}
    \caption{Flask Service Architecture}
    \label{fig:flask_service_architecture}
\end{figure}

\subsection{System Architecture}

The system is organized around a central Python script, \texttt{app.py}, which handles incoming requests, registers endpoints, initiates the server, and manages logging. Server configuration is maintained in \texttt{config.py}, where settings such as the language model, image processing rules, upload folder, and conversion language are defined.

Endpoints are organized within the \texttt{routes} subfolder, with similar endpoints grouped together. They are divided into the following files:
\begin{itemize}
    \item \textbf{chatbot\_route.py:} Contains endpoints related to chatbot functionality.
    \item \textbf{Image\_recognition\_route.py:} Manages endpoints for image recognition tasks.
    \item \textbf{Programming\_bot\_route.py:} Houses endpoints for the programming bot.
\end{itemize}

Within these files, endpoints process user requests and return responses, and are designed for easy extension. They also handle error management and user feedback by converting data from the user and the Ollama API into the appropriate format when necessary. Connections to the Ollama API and the OCR (Optical Character Recognition) system are managed within the \texttt{Utils} folder, which contains all utility functions used by the endpoints, including those for sending requests, performing OCR, and converting Markdown to HTML.

\subsection{Expandability and Modularity}

The server is designed for easy expandability and modularity. Endpoints are stored in separate files, which allows for the straightforward addition of new functionality. Similarly, utility functions can be updated or replaced with minimal effort, and the server configuration is flexible enough to accommodate new parameters.

This modular and extensible architecture ensures that the Flask service can readily adapt to future enhancements and integrations. These design principles contribute to a flexible, maintainable server that can be effortlessly updated with new features and functionalities.

% ***************************************************

\section{Flask as a Web Framework}

\subsection{Core Functionalities of Flask}
This subsection explains the intrinsic capabilities of Flask, such as request routing, templating, and middleware support. It illustrates how these features are employed to manage web requests and responses within the service.

\subsection{Rationale for Selecting Flask}
A critical discussion is presented on why Flask was chosen for the project. Key factors include its simplicity, extensive documentation, and robust community support, which collectively make it an ideal framework for rapid development and prototyping.

\section{RESTful Endpoints and Functionalities}
\label{sec:endpoints}
\subsection{Endpoint Specifications}
This section enumerates the various RESTful endpoints implemented in the service. Each endpoint is described in detail, outlining its specific purpose and the type of data it handles.

\subsection{Code Illustrations}
To enhance understanding, code examples are provided to demonstrate the implementation of key endpoints. These examples highlight the methods used to process requests and generate responses.
\subsection{Utility Functions}
An overview of auxiliary utility functions is given, focusing on their roles in logging, data validation, and error handling. These functions contribute to the overall robustness and reliability of the service.


\section{Utilized Libraries}
A comprehensive inventory of the external libraries used in the project is presented in this section. For each library, its functionality, role within the project, and integration aspects are discussed.


\section{Deployment}

% How we deployed the Server on a Laptop, The School Server and on our Server via Docker
% Explain how we Deployed the Server on a Laptop, The School Server and on our Server via Docker (Docker gets Explained in the next Section)

%###################

\section{Docker}
\label{sec:docker}
Docker is a platform that allows you to run applications in containers. A container is like a small, isolated environment where software runs with everything it needs – including the operating system, libraries, and dependencies.

No matter which computer or server the container runs on, it always works the same way. This means you don’t have to worry about an application suddenly throwing errors on a different system just because a different software version is installed there.

Docker is often used in software development and cloud applications because it simplifies testing, deployment, and scaling of apps. Developers can store their software as images and share them with others without requiring complicated installations.

\subsection{Used Docker Images}
A docker image is a blueprint that specifies how to run the application. The instructions for the build are stored in the Dockerfile.
\cite{dockerize_flask} 

\begin{itemize}
    \item \textbf{flask\_app} The Flask image is used to easily implement the Flask application in a Docker container.
    \item \textbf{ollama} The Ollama image is used to avoid running LLMs globally and use them in a secluded environment.
\end{itemize}

\subsection{Docker Compose}
Docker Compose is used for running multiple containers at the same time. It simplifies your application and makes it easier to manage 
The Configuration is stored in a single YAML file. All the services can be started with a simpel command. It is a very compact way to manage Docker application.
\cite{docker_compose} 

\author{Florian Prandstetter}

\section{Scalability and Performance Concerns}

One notable limitation of the Flask server is its inherent lack of scalability. Flask, being primarily designed for lightweight applications, is not optimized for handling high volumes of concurrent requests. In our implementation, the server was deployed on a modest PC with limited computational resources. Consequently, if the service were to be deployed in a production environment, it would be imperative to migrate to more robust hardware or consider a distributed, multi-server architecture to effectively manage the anticipated load. Given the constraints of the project timeline and the prototype nature of this work, scalability was not prioritized during development.

% ########################################

\section{Conclusion and Future Work}
This concluding section synthesizes the chapter’s key points and reflects on the efficacy of the implemented service. It also outlines potential avenues for future enhancements, such as further scalability improvements, additional functionalities, and more robust deployment automation.





